---
layout: post
title: iOS面试题总结二
category: 技术
tags: iOS,Objective-C
description:
---
说明：这是iOS面试题总结的第二篇，主要会写一些关于Objective-C相关的知识点。如果有什么错误的地方请联系我:QQ:512869343 

### 1.#import 和 #include，@class区别。
 #import可以确保头文件只被引用一次，可以避免递归包含的问题。
 #import 会链入头文件的全部信息，包括类的实例变量和方法等；而@class只是告诉编译器，其后跟随名称是一个类的名称，至于类中的细节，暂时不需要去考虑。当然如果.m文件需要用到这个类时，需要引用具体的头文件了。。@class 主要能够解决循环依赖的问题。比如A->B,B->A.
 
### 2. 在一个对象的方法里面:self.name=@"xxx",和name=@"xxx"有什么不同吗？
self.name = @"x"会调用对象的设置方法setName方法；
name = @"xxx";会直接把@"xxx"直接复制给当前对象的实例变量。

### 3.请简述self.name=nil的机制，以及[name release]的区别
self.name = nil; 其实就是调用setName这个设置方法，将name 进行释放，
[name release]; 这个方法调用会直接印象到name的引用计数，如果为0那么会在下一帧调用其dealloc 释放器内存.

### 4.Objective-C中有没有私有方法？私有变量？一般采用什么方法实现？
Objective-C 类中只有两种方法：实例方法和类方法。那么如何在类中申明私有方法呢？因为一个OO程序设计中，私有方法是不可或缺的，我们只需要也仅仅需要把我们需要暴露的方法和变量设置为共有。其他的都设置为私有。我们可以在分类中实现也就是在类申明对应的.m文件中进行设置。这样类外部的代码就不能访问到这些方法和变量了。 而对于变量而言，我们可以使用@private来修饰变量。在OC中所有实例变量默认都是私有的，所有方法都是共有的。

### 5.说说ARC机制
ARC就是 automatic reference counting,简单来讲其实就是编译器在编译代码时，自动将retain/release,autorelease,MRC里面需要手动书写的内存管理代码全部都用编译器为我们完成。
那么到底是使用ARC好，还是MRC好呢？
在我的观点来说，使用ARC要好过MRC，因为编译器对ARC做了很多优化，比如在使用retain和release时，它其实是直接调用的C相关的接口，直接越过了OC runtime中的消息处理机制，并且会对代码中的一些地方进行优化，跟少的使用操作引用计数的方法。
使用ARC还可以使得代码简洁，易读（这是我认为最好的地方）

### 6.自动释放池是什么，如何工作
当你向一个对象发送一个autorelase消息时，OC就会把该对象的引用放入到最新的自动释放池中，它任然是个正常的对象，自动释放池所定义的作用域内的其他对象任然可以向它发送消息。当作用域结束时，自动释放池就会释放，当然期内的所有对象其引用计数也会见一，如果引用计数为0的就会被系统回收。
工作原理：

* OC是通过引用计数的方式来管理内存的，对象在开始创建时(alloc)其引用计数为1，后面每次碰到retain,copy时，引用计数都会加一，每当碰到release和autorelease时引用计数减一，知道引用计数为0时，就会被系统回收
* autorelease 和release 其实没有什么区别，只是在引用计数减一的时机上有所不同，release是立即就减一，而autorelase是在到了作用域结束时，再减一。

### 7.OC的优缺点
优点:
* 它是ANSI C的超集，扩展了C语言并且支持了面向对象的设计能力，比如，类，消息，多态，数据的封装。同时它可以和C++混合使用，可以通过C++对象访问方法。
* OC的Runtime机制，在我看来是OC的最佳优点
* Categories,使得在不继承类的情况下，可以在其他代码地方扩展现有类。
* Posing ,冒充，其和Categories类似，但是本质不一样，Posing存在的目的在于子类可以冒充父类，使得后续的代码无需吧父类修改为子类，就可以非常方便的让父类表现为子类的行为，它允许你扩展一个calss,并且全面冒充这个super class,比如一个扩展NSArray的NSArrayChild对象，如果你让NSArrayChild冒充NSArray,则你程序代码所在的NSArray都会被替换为NSArrayChild.

缺点:
* 不支持命名空间
* 不支持运算符重载
* 不支持多重继承
* 使用动态允许时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。

### 8.类别的作用？继承和类别在实现中有何区别？
类别可以在不知道，不改变原代码的情况下往里面添加新的方法，当然只能添加不能修改。如果类别中的方法和类中的名称冲突，则类别的将会覆盖原方法。因为类别具有更高的优先级。类别有三个作用：1.将类的实现分散到多个不同文件或多个不同框架中。2.创建对私有方法的前向引用。3.向对象增加非正式协议。继承可以增加修改方法，并且可以增加属性。

### 9.通知和协议的不同之处？
协议有控制链关系。而通知没有。通知可以一对多，一条消息可以发送给多个消息接受者，代理却是一对一关系。
### 10.多态性
在我的理解中，就是调用同一个函数名字，根据响应的对象不同，表现出不同的行为。比如父类有个方法print用来打印父类自己的名字，子类重写了它，然后每次我们向他们发送print消息是，他们打印的就是自己的名字。

### 11.KVC和KVO
KVC:Key-Value Coding 即是指NSKeyValueCoding,一个非正式Protocol,提供一种机制来间接访问对象的属性，而KVO就是在KVC基础上实现的关键技术之一。
KVO:Key-value Observing就是建立在KVC之上，它能够观察对象的KVC key patch值的变化。当值发生变化时就会收到通知。

### 12.copy和retain的区别
retain:相当于指针拷贝。变量的引用计数加1.两个指针都指向同一个地址
copy:内容拷贝，变量的引用计数加1，但是其本身的计数不变，申请一块新的内存放入相同的变量进去。

### 13.什么情况适用weak关键字，相比assign有什么不同?
什么情况使用weak关键字?

* 1.在ARC中，有可能出现循环引用的时候，往往通过让其中一端使用weak来解决，比如delegate代理属性
* 2.自身已经对它进行了一次强引用，没有必要再强引用一次，此时也会使用weak.

和assign的不同点

* 1.wak此特质表面该属性定义了一中非拥有关系，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指对象遭到销毁时，属性会自动清空。而assign的设置方法只会针对基本数据类型的简单赋值。
* 2. assign可以用于非OC对象，而weak必须用于OC对象。

### 14.怎么使用copy关键字?
用途：

* 1.NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型,NSMutableArray,NSMutableString,NSMutableDictionary；
* 2. block经常使用copy关键字，block使用copy是从MRC中遗留下来的一个传统，在MRC中，方法内部的block是在栈去的，使用copy可以把它放在堆区，在ARC中写不写都行，

	注:@propety申明NSString、NSArray、NSDictionary经常使用copy关键字，是因为他们都对应有可变类型:NSMutableXX,他们之间可能进行赋值操作，为了确保对象中的属性不会在无意间改动，应该在设置新属性时拷贝一份。



